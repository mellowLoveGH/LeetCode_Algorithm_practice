# -*- coding: utf-8 -*-
"""Algo_practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10HvaST7m3Rb_8d-JiBXHDtRgit16TyUu
"""

# basic calculator, only for +, - and ()
# LeetCode-Solution
class Solution:
    def calculate(self, s: str) -> int:
        ops = [1]
        sign = 1

        ret = 0
        n = len(s)
        i = 0
        while i < n:
            print(ops, sign, ret)
            # if space, skip
            if s[i] == ' ':
                i += 1
            elif s[i] == '+':
                sign = ops[-1]
                i += 1
            elif s[i] == '-':
                sign = -ops[-1]
                i += 1
            elif s[i] == '(':
                ops.append(sign)
                i += 1
            elif s[i] == ')':
                ops.pop()
                i += 1
            else:
                num = 0
                while i < n and s[i].isdigit():
                    num = num * 10 + ord(s[i]) - ord('0')
                    i += 1
                ret += num * sign
            
        return ret

sol = Solution()
sol.calculate('(1-(4+5-2)-3)+(6+8)')

# leetcode
# 1.
class MyHashSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.col = set()


    def add(self, key: int) -> None:
        self.col.add(key)

    def remove(self, key: int) -> None:
        if self.contains(key):
            self.col.remove(key)

    def contains(self, key: int) -> bool:
        """
        Returns true if this set contains the specified element
        """
        if key in self.col:
            return True 
        else:
            return False

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

st = "hello"
st[0]

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        v1 = 0
        t1 = l1
        base = 1
        while t1 is not None:
            v1 = v1 + base * t1.val
            t1 = t1.next
            base = base * 10
        print(v1)
        v2 = 0
        t2 = l2
        base = 1
        while t2 is not None:
            v2 = v2 + base * t2.val
            t2 = t2.next
            base = base * 10
        print(v2)
        s = v1 + v2
        print(s)
        st = str(s)
        L = len(st) - 1
        t = ListNode(int(st[0]))
        i = 1
        while i<=L:
            ln = ListNode( int(st[i]), t )
            t = ln
            i = i + 1
        return t

# 4.
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        L = 0
        maxL = 0
        sub  = ""
        for ch in s:
            if ch not in sub:
                L = L + 1
                sub = sub + ch
                if L > maxL:
                    maxL = L
            else:
                pos = sub.find(ch)
                #print(pos)
                sub = sub[pos+1:] + ch
                #print(sub)
                #sub = ch + ""
                L = len(sub)
                if L > maxL:
                    maxL = L

        return maxL


# 5.
class Solution1:
    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
        merge = nums1
        for i in nums2:
            merge.append(i)
        merge = sorted(merge)
        L = len(merge)
        if L % 2 == 1:
            return merge[ L//2 ]
        else:
            return (merge[ L//2 ] + merge[ L//2 - 1])/2

5//2

class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) <= 1:
            return s
        if len(s) == 2 and s[0] == s[1]:
            return s
        L = len(s)
        target = ""
        for i in range(L):
            for j in range(i+1, L+1):
                #print(i, j)
                if i<j:
                    sub = s[i:j]
                    #print(sub, self.check(sub))
                    if self.check(sub) and len(sub) > len(target):
                        target = sub


        return target
    
    def check(self, sub):
        L = len(sub) - 1
        i = 0
        while i <= L:
            if sub[i] != sub[L]:
                return False
            i = i + 1
            L = L - 1

        return True

class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) <= 1:
            return s
        if len(s) == 2 and s[0] == s[1]:
            return s
        L = len(s)
        
        target = ""
        for i in range(L):
            print(i)
            left, right, sub = self.expand(s, i, i)
            if len(sub) >= len(target):
                target = sub
            left, right, sub = self.expand(s, i, i+1)
            if len(sub) >= len(target):
                target = sub
            #print(target)
        return target
    
    def expand(self, s, left, right):
        while left>=0 and right<len(s) and s[left] == s[right]:
            left = left - 1
            right = right + 1
        #print('--', left+1, right-1, s[left+1:right])
        return left, right, s[left+1:right]

tmp = Solution()
tmp.longestPalindrome("babad")

import math
class Solution:
    def reverse(self, x: int) -> int:
        if x>0:
            st = str(x)
            base = 1
            v = 0
            for i in st:
                v = v + base*int(i)
                base = base * 10
            if v > math.pow(2, 31)-1:
                return 0
            return v
        else:
            x = -x
            st = str(x)
            base = 1
            v = 0
            for i in st:
                v = v + base*int(i)
                base = base * 10
            v = -v
            if v < -math.pow(2, 31):
                return 0
            return v
tmp =Solution()
tmp.reverse(1534236469)
math.pow(2, 31) -1
# 2147483647.0
# 1534236469

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x<0:
            return False
        else:
            num = x
            v = 0
            while num > 0:
                n = num%10
                v = v*10 + n
                num = num // 10
            print(v)
        return v==x
tmp =Solution()
tmp.isPalindrome(123)

class Solution:
    def romanToInt(self, s: str) -> int:
        dic = { 'I':1, 'V':5,  'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
        size = len(s)
        i = 0
        re = 0
        while i < size:
            cur = dic[s[i]]
            if i+1<size:
                nex = dic[s[i+1]]
                # 
                if cur >= nex:
                    re = re + cur
                    i = i + 1
                else:
                    re = re + nex - cur
                    i = i + 2
            else:
                re = re + cur
                i = i + 1      

        return re

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) < 1:
            return ""
        pre = ""
        i = 0
        while True:
            flag = True
            if i >= len(strs[0]):
                break
            ch = strs[0][i]
            for sub in strs:
                if i >= len(sub):
                    flag = False
                    break
                if sub[i] != ch:
                    flag = False
                    break
            i = i + 1
            if flag:
                pre = pre + ch
            else:
                break
        return pre

class Solution:
    def isValid(self, s: str) -> bool:
        dic = { '(':1, ')':-1, '[':2, ']':-2, '{':3, '}':-3 }
        stk = []
        for ch in s:
            v = dic[ch]
            if v > 0:
                stk.append(v)
            else:
                if len(stk) == 0:
                    return False
                flag = v + stk.pop()
                if flag != 0:
                    return False
        return len(stk) == 0

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        #
        h = None
        h1 = l1
        h2 = l2
        while h1 and h2:
            if h1.val > h2.val:
                tmp = ListNode(h2.val, h)
                h = tmp
                h2 = h2.next
            else:
                tmp = ListNode(h1.val, h)
                h = tmp
                h1 = h1.next
        while h1:
            tmp = ListNode(h1.val, h)
            h = tmp
            h1 = h1.next
        while h2:
            tmp = ListNode(h2.val, h)
            h = tmp
            h2 = h2.next
        #
        hh = None
        while h:
            tmp = ListNode(h.val, hh)
            hh = tmp
            h = h.next

        return hh







class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        L = len(nums)
        if L < 1:
            return 0
        if L == 1:
            return 1
        i = 0        
        while i< L-1:
            cur = nums[i]
            j = i + 1
            nex = nums[j]
            while nex <= cur and j<L-1:
                j = j + 1
                nex = nums[j]
            if nex <= cur:
                break
            else:
                nums[j] = nums[i+1]
                nums[i+1] = nex
            i = i + 1
        #print(nums)
        return i+1

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        L = len(nums)
        N = 0
        i = 0
        while i<L:
            if nums[i] == val:
                N = N + 1
            i= i+1

        j = 0
        u = 0
        while j<L-1:            
            k = j
            cur = nums[j]
            while cur == val and k<L:
                self.update(nums, j)
                k = k + 1
                cur = nums[j]   
                u = u +1
            j = j + 1
        print(nums)
        print(L-N)        

        return L - N

    
    def update(self, nums, i):
        L = len(nums)
        while i<L-1:
            nums[i] = nums[i+1]
            i = i + 1

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        L1 = len(haystack)
        L2 = len(needle)
        if L1 < L2:
            return -1
        if L1==0 and L1==L2:
            return 0
        i = 0
        while i<=L1-L2:
            flag = True
            j = 0
            while j < L2:
                if haystack[i+j] != needle[j]:
                    flag = False
                    break
                j = j + 1
            if flag:
                return i
            i = i + 1
        return -1

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        L = len(nums)
        i = 0
        pv = nums[i]
        while i < L:
            if nums[i] == target:
                return i
            if target < nums[i]:
                return i
            i = i + 1
        return L

class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return "1"
        line = "1"
        i = 1
        while i < n:
            # 描述
            pre = ""
            pos = []
            val = []
            #cur = line[0]
            j = 0
            while j < len(line):
                ch = line[j]
                if ch != pre:
                    pos.append(j)
                    val.append(ch)
                    pre = ch
                j = j + 1

            # 转换成字符串
            nl = ""
            k = 0
            while k < len(pos):
                sub = ""
                if k == len(pos)-1:
                    sub = line[ pos[k]: ]
                else:
                    sub = line[ pos[k]: pos[k+1] ]
                nl = nl + str(len(sub))+str(val[k])
                k = k + 1
            line = nl
            i = i + 1       

        return line

class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows <= 1:
            return s
        padding = ' '
        nr = numRows - 1
        rd = numRows * 2 - 2
        ns = ""
        i = 0
        L = len(s)
        col = 0
        while i < L:
            ch = s[i]
            n1 = i%rd
            if n1 < numRows:
                ns = ns + ch
                col = 0
            else:
                col = col + 1
                col = col % nr
                af = col
                bf = nr - af
                j = 0
                while j<bf:
                    ns = ns + padding
                    j = j + 1
                ns = ns+ch
                j = 0
                while j<af:
                    ns = ns + padding
                    j = j + 1
            i = i + 1
        print(ns)
        line = ""
        i = 0
        while i<numRows:
            step = numRows
            j = i 
            while j<len(ns):
                if ns[j] != ' ':
                    line = line + ns[j]
                j = j + step
            i = i + 1
        return line

import math
class Solution:
    def myAtoi(self, s: str) -> int:
        s = s.strip()
        L = len(s)
        if L < 1:
            return 0
        first = s[0]
        if self.isdigit(first) or first == '-' or first == '+':
            sub = "" + first
            for ch in s[1:]:
                if self.isdigit(ch):
                    sub = sub+ch
                else:
                    break
            print('---)', len(sub))
            if sub == '-' or sub=='+':
                return 0
            v = int(sub)
            mx = int(math.pow(2, 31) - 1)
            mn = int(-math.pow(2, 31))
            if v<mn:
                return mn
            elif v>mx:
                return mx
            else:
                return  v

        else:
            return 0
        
    def isdigit(self, ch):
        if ch>='0' and ch<='9':
            return True
        else:
            return False

class Solution:
    def maxArea(self, height: List[int]) -> int:
        L = len(height)
        i = 0
        j = 0
        mx = 0
        H = max(height)
        h = H
        while h>0:
            i, j = self.findIndex(height, h, L)
            print(i, j)
            if i>=0 and j>i:
                a = self.area(height, i, j)
                if mx < a:
                    mx = a
            h = h-1

        return mx
    
    def findIndex(self, height, h, L):
        i = 0
        j = L - 1
        idx01 = -1
        idx02 = -1
        while i<L:
            if height[i] >= h:
                idx01 = i
                break
            i = i+1
        print(idx01)
        while j>i:
            if height[j] >= h:
                idx02 = j
                break
            j = j-1
        if idx01 >=0 and idx02>idx01:
            return idx01, idx02
        return -1, -1

    def area(self, height, i, j):
        h1 = height[i]
        h2 = height[j]
        h = 0
        if h1<h2:
            h = h1
        else:
            h = h2
        b = j - i 
        return b*h